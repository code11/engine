"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[239],{2026:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var i=n(7250),s=n(9596);const o={id:"state-is-king",title:"State is King!",sidebar_label:"State is King"},a=void 0,d={id:"tutorials/react/state-is-king",title:"State is King!",description:"State of the app when it has just started up (aka",source:"@site/docs/tutorials/react/state-is-king.md",sourceDirName:"tutorials/react",slug:"/tutorials/react/state-is-king",permalink:"/engine/docs/tutorials/react/state-is-king",draft:!1,unlisted:!1,editUrl:"https://github.com/code11/engine/edit/master/docs/docs/tutorials/react/state-is-king.md",tags:[],version:"current",frontMatter:{id:"state-is-king",title:"State is King!",sidebar_label:"State is King"},sidebar:"docs",previous:{title:"Static UI",permalink:"/engine/docs/tutorials/react/static-ui"},next:{title:"Accessing State",permalink:"/engine/docs/tutorials/react/accessing-state-in-components"}},r={},c=[];function l(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/concepts/state",children:"State"})," of the app when it has just started up (aka\ninitial state) can be given to when it is\ninstantiated:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:'const app = engine({\n+ state: {\n+   initial: { }\n+ },\n  view: {\n    element: <App />,\n    root: "#root"\n  }\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Usually there would be a unique ",(0,i.jsx)(t.code,{children:"id"})," in the database which can uniquely identify\na todo. While building only the UI, such identifier isn't available. So the app\nwill add a fake ",(0,i.jsx)(t.code,{children:"id"})," into every todo item it creates."]}),"\n",(0,i.jsxs)(t.p,{children:["Types are immensely helpful in modeling domain objects. Create a ",(0,i.jsx)(t.code,{children:"src/types.ts"}),"\nfile, and add how the ",(0,i.jsx)(t.code,{children:"TodoItem"})," is going to be shaped like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'export enum TodoStatuses {\n  pending = "pending",\n  done = "done",\n}\n\nexport interface TodoItem {\n  id: string;\n  title: string;\n  status: TodoStatuses;\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Notice that for the status of ",(0,i.jsx)(t.code,{children:"TodoItem"}),"s, an enum of statuses is used instead\nof a boolean flag (e.g ",(0,i.jsx)(t.code,{children:"isDone"})," or ",(0,i.jsx)(t.code,{children:"isPending"}),"). It is an ",(0,i.jsx)(t.a,{href:"/docs/best-practices#prefer-explicit-types-for-defining-states",children:"Engine best\npractice"})," to\nprefer explicit types over boolean flags."]}),"\n",(0,i.jsxs)(t.p,{children:["Knowledge of the shape of ",(0,i.jsx)(t.code,{children:"TodoItem"}),"s allows adding some initial todos the\napplication state. In ",(0,i.jsx)(t.code,{children:"src/index.tsx"})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-diff",children:"const app = engine({\n  state: {\n-   initial: { }\n+    todosById: {\n+      todo1: { id: 'todo1', title: 'Add initial state to engine', status: \"pending\", mode: \"viewing\" },\n+      todo2: { id: 'todo2', title: 'Use initial state in components', status: \"done\", mode: \"viewing\" },\n+      todo3: { id: 'todo3', title: 'Update state in components', status: \"pending\", mode: \"editing\" }\n+     },\n+     visibleTodoIds: ['todo1', 'todo2']\n   },\n  view: {\n    element: <App />,\n    root: \"#root\"\n  }\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Todo items are kept in very explicitly named ",(0,i.jsx)(t.code,{children:"todosById"})," key, and their ",(0,i.jsx)(t.code,{children:"id"}),"s\nare also added in a ",(0,i.jsx)(t.code,{children:"visibleTodoIds"})," array. This a deliberate choice with ",(0,i.jsx)(t.a,{href:"/docs/concepts/state#shape-of-state",children:"good\nreasons"}),". One of the app components (Todo listing)\nhappens to show a list of todo items. These shown todos might (and will) end up\nbeing different from our ",(0,i.jsx)(t.code,{children:"todosById"}),". Keeping them in their own path in state\nallows keeping a normalized state. It is crucial for maintainability that a\nsingle source of truth for data is maintained."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"todosById"})," will often be referred to in the app. Create a type alias for it is\nhelpful to not have to repeat it over and over again. In ",(0,i.jsx)(t.code,{children:"src/types.ts"}),", add:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"export type TodosById = { [id: string]: TodoItem };\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It's time to show the ",(0,i.jsx)(t.code,{children:"TodoItem"}),"s from state in our component."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},9596:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var i=n(7402);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);