"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3304],{8823:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var s=t(7250),o=t(9596);const a={id:"flags",title:"Flags",sidebar_label:"Flags"},r=void 0,i={id:"patterns/flags",title:"Flags",description:"Flags store conclusions regarding the state of some data. Usually a producer",source:"@site/docs/patterns/flags.md",sourceDirName:"patterns",slug:"/patterns/flags",permalink:"/engine/docs/patterns/flags",draft:!1,unlisted:!1,editUrl:"https://github.com/code11/engine/edit/master/docs/docs/patterns/flags.md",tags:[],version:"current",frontMatter:{id:"flags",title:"Flags",sidebar_label:"Flags"},sidebar:"docs",previous:{title:"Collections",permalink:"/engine/docs/patterns/collections"},next:{title:"Request-Response",permalink:"/engine/docs/patterns/request-response"}},l={},c=[];function d(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Flags store conclusions regarding the state of some data. Usually a producer\nwill observe some data and then update a single location with flag information.\nIn this way decisions avoid being computed where they are needed and instead\nrely on the state to provide this information."}),"\n",(0,s.jsx)(n.p,{children:"Keeping flags on the state decreases complexity and helps code to be more\nmodular."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"user.isAuth"})," is populated by a producer that uses different sources (local\nstorage, session, etc) to determine wheter the user has a valid session or not,\nand stores this information in the state."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{\n  user: {\n    isAuth: true\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"balloons.items.*.isInflated"})," is populated by a producer that observes\n",(0,s.jsx)(n.code,{children:"ballons.items.*.capacity"})," and ",(0,s.jsx)(n.code,{children:"balloons.items.*.air"}),". If the air will equal the\ncapacity it will update the path with ",(0,s.jsx)(n.code,{children:"true"})," otherwise, it'll be ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"balloons.areInflated"})," is populated by a producer that observes\n",(0,s.jsx)(n.code,{children:"balloons.items.*.isInflated"})," and ",(0,s.jsx)(n.code,{children:"balloons.count"})," and will update the\n",(0,s.jsx)(n.code,{children:"areInflated"})," path once the ",(0,s.jsx)(n.code,{children:"isInflated"})," count is equal to the ",(0,s.jsx)(n.code,{children:"balloons.count"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  balloons: {\n    items: {\n      "abc": {\n        isInflated: false,\n        air: 40,\n        capacity: 100,\n      },\n      "xyz": {\n        isInflated: true,\n        air: 80,\n        capacity: 80,\n      }\n    },\n    count: 2,\n    areInflated: false,\n  }\n\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},9596:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(7402);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);