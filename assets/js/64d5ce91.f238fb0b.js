"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8170],{6470:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>a});var o=t(7250),r=t(9596);const s={id:"introducing-producers",title:"Introducing Producers",sidebar_label:"Producers"},c=void 0,i={id:"tutorials/react/introducing-producers",title:"Introducing Producers",description:"producers are the central concept of Engine. Engine",source:"@site/docs/tutorials/react/introducing-producers.md",sourceDirName:"tutorials/react",slug:"/tutorials/react/introducing-producers",permalink:"/engine/docs/tutorials/react/introducing-producers",draft:!1,unlisted:!1,editUrl:"https://github.com/code11/engine/edit/master/docs/docs/tutorials/react/introducing-producers.md",tags:[],version:"current",frontMatter:{id:"introducing-producers",title:"Introducing Producers",sidebar_label:"Producers"},sidebar:"docs",previous:{title:"Updating State",permalink:"/engine/docs/tutorials/react/updating-state-from-components"},next:{title:"State as Communication Channel",permalink:"/engine/docs/tutorials/react/state-as-communication-channel"}},d={},a=[];function l(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/docs/api/producer",children:"producer"}),"s are the central concept of Engine. Engine\nrecommends that our components should only represent the view, and have as\nlittle logic as possible. Producers are where the logic lives in an Engine app."]}),"\n",(0,o.jsxs)(n.p,{children:["Simplest place to see producers in action can be Todo list's footer. A producer\nwill count the number of pending todos, and show them in the view. Extract\n",(0,o.jsx)(n.code,{children:"Footer"})," out of ",(0,o.jsx)(n.code,{children:"src/App.tsx"})," into its own component. Create ",(0,o.jsx)(n.code,{children:"src/Footer.tsx"}),"\nwith following contents:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'const Footer = () => (\n  <footer className="footer">\n    <span className="todo-count">\n      <strong>1</strong> items left\n    </span>\n    <ul className="filters">\n      <li>\n        <a href="#/" className="selected">\n          All\n        </a>\n      </li>\n      <li>\n        <a href="#/active">Active</a>\n      </li>\n      <li>\n        <a href="#/completed">Completed</a>\n      </li>\n    </ul>\n    <button className="clear-completed">Clear completed</button>\n  </footer>\n);\n\nexport default Footer;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Update ",(0,o.jsx)(n.code,{children:"src/App.tsx"})," to use ",(0,o.jsx)(n.code,{children:"Footer"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'+ import Footer from "./Footer";\n...\n-    <footer className="footer">\n-      <span className="todo-count">\n-        <strong>1</strong> items left\n-      </span>\n-      <ul className="filters">\n-        <li>\n-          <a href="#/" className="selected">\n-            All\n-          </a>\n-        </li>\n-        <li>\n-          <a href="#/active">Active</a>\n-        </li>\n-        <li>\n-          <a href="#/completed">Completed</a>\n-        </li>\n-      </ul>\n-      <button className="clear-completed">Clear completed</button>{" "}\n-    </footer>\n+    <Footer />\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Footer"})," will trust that ",(0,o.jsx)(n.code,{children:"pendingCount"})," is going to be available in the state,\nand that ",(0,o.jsx)(n.code,{children:"it'll always contain the correct number of pending todo items. Update "}),"src/Footer.tsx` based on this assumption:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'- const Footer = () => (\n+ const Footer: view = ({ pendingCount = observe.pendingCount }) => (\n  <footer className="footer">\n    <span className="todo-count">\n-     <strong>1</strong> items left\n+     <strong>{pendingCount}</strong> items left\n    </span>\n    <ul className="filters">\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The logic for counting pending items in the ",(0,o.jsx)(n.code,{children:"Footer"})," itself, in fact, in a\ntraditional React app that's exactly what we would have done. But Engine\nstrongly recommends that business logic should be kept out of ",(0,o.jsx)(n.code,{children:"view"}),"s, and put\nit in ",(0,o.jsx)(n.code,{children:"producer"}),"s. Add a ",(0,o.jsx)(n.code,{children:"producer"})," to the Footer. In ",(0,o.jsx)(n.code,{children:"src/Footer.tsx"}),", add\n",(0,o.jsx)(n.code,{children:"pendingCounter"})," producer:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"+ const pendingCounter: producer = ({\n+   updatePendingCount = update.pendingCount,\n+   todosById = observe.todosById\n+ }) => {\n+   const pendingCount = Object.values(\n+     todosById as TodosById\n+   ).reduce(\n+     (accum: number, todo) =>\n+       todo.status === TodoStatuses.done ? accum : accum + 1,\n+     0\n+   );\n+\n+   updatePendingCount.set(pendingCount);\n+ };\n+\n+ Footer.producers([pendingCounter]);\n\nexport default Footer;\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"producer"}),"s are just normal functions which are labeled with\n",(0,o.jsx)(n.a,{href:"/docs/api/producer",children:"producer"})," macro. They can access the state the same way as\n",(0,o.jsx)(n.code,{children:"view"}),"s; they even have access to ",(0,o.jsx)(n.code,{children:"prop"}),"s that a view might get from its parent."]}),"\n",(0,o.jsxs)(n.p,{children:["To add a producer to a component, ",(0,o.jsx)(n.code,{children:".producers"})," property of a view is given an\narray of producers."]}),"\n",(0,o.jsxs)(n.p,{children:["Similar to ",(0,o.jsx)(n.code,{children:"view"}),"s, a producer is triggered whenever anything that it ",(0,o.jsx)(n.code,{children:"observe"}),"s\nchanges. ",(0,o.jsx)(n.code,{children:"pendingCounter"})," producer Observes ",(0,o.jsx)(n.code,{children:"todosById"})," object, so whenever\nanything in todosById changes, this producer is executed. Whenever status of any\ntodo item is updated, ",(0,o.jsx)(n.code,{children:"pendingCount"})," gets updated accordingly."]}),"\n",(0,o.jsx)(n.p,{children:"In the next chapter, we'll take a look at how producers make it possible to a\nvery create workflow for view producer communication."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},9596:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var o=t(7402);const r={},s=o.createContext(r);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);