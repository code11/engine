"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1435],{2979:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});var o=t(7250),s=t(9596);const d={id:"state-as-communication-channel",title:"State as Communication Channel",sidebar_label:"State as Communication Channel"},i=void 0,r={id:"tutorials/react/state-as-communication-channel",title:"State as Communication Channel",description:"It's time to make it possible to add new TodoItems to the state. To start off,",source:"@site/docs/tutorials/react/state-as-communication-channel.md",sourceDirName:"tutorials/react",slug:"/tutorials/react/state-as-communication-channel",permalink:"/engine/docs/tutorials/react/state-as-communication-channel",draft:!1,unlisted:!1,editUrl:"https://github.com/code11/engine/edit/master/docs/docs/tutorials/react/state-as-communication-channel.md",tags:[],version:"current",frontMatter:{id:"state-as-communication-channel",title:"State as Communication Channel",sidebar_label:"State as Communication Channel"},sidebar:"docs",previous:{title:"Producers",permalink:"/engine/docs/tutorials/react/introducing-producers"},next:{title:"Wrapping Up",permalink:"/engine/docs/tutorials/react/wrapping-up"}},a={},c=[];function l(e){const n={a:"a",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["It's time to make it possible to add new ",(0,o.jsx)(n.code,{children:"TodoItem"}),"s to the state. To start off,\nextract ",(0,o.jsx)(n.code,{children:"TodoForm"})," view out of ",(0,o.jsx)(n.code,{children:"src/App.tsx"}),". Create a new file\n",(0,o.jsx)(n.code,{children:"src/TodoForm.tsx"})," with following contents:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'const TodoForm = () => (\n  <input\n    className="new-todo"\n    placeholder="What needs to be done?"\n    autoFocus={true}\n  />\n);\n\nexport default TodoForm;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Update ",(0,o.jsx)(n.code,{children:"src/App.tsx"})," accordingly:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'+ import TodoForm from "./TodoForm";\n...\n-    <input\n-      className="new-todo"\n-      placeholder="What needs to be done?"\n-      autoFocus={true}\n-    />\n+    <TodoForm />\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Since global-state is the only kind of state recommended in Engine, a state\nvariable should be kept for what user is typing in our ",(0,o.jsx)(n.code,{children:"TodoForm"})," input. Update\n",(0,o.jsx)(n.code,{children:"src/TodoForm.tsx"})," to make its content be:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'const TodoForm: view = ({\n  updateNewTodoTitle = update.newTodo.title,\n  newTodoTitle = observe.newTodo.title,\n}) => (\n  <input\n    className="new-todo"\n    placeholder="What needs to be done?"\n    autoFocus={true}\n    value={newTodoTitle || ""}\n    onChange={(e) => updateNewTodoTitle.set(e.currentTarget.value)}\n  />\n);\n\nexport default TodoForm;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Above snippet:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Labeled ",(0,o.jsx)(n.code,{children:"TodoForm"})," as ",(0,o.jsx)(n.code,{children:"view"}),", so that it can use ",(0,o.jsx)(n.a,{href:"/docs/api/observe",children:"observe"}),"\nand ",(0,o.jsx)(n.a,{href:"/docs/api/update",children:"update"})," in its header"]}),"\n",(0,o.jsxs)(n.li,{children:["Introduced a new state path ",(0,o.jsx)(n.code,{children:".newTodo.title"})]}),"\n",(0,o.jsxs)(n.li,{children:["Update ",(0,o.jsx)(n.code,{children:"newTodo.title"})," whenever user enters something in the ",(0,o.jsx)(n.code,{children:"<input>"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A new todo should be added to the ",(0,o.jsx)(n.code,{children:"todosById"})," object whenever user presses\n",(0,o.jsx)(n.code,{children:"Enter"})," key in the input. It is possible to create an event handler in the view\nitself which does this work, but Engine recommends to not do it from the ",(0,o.jsx)(n.code,{children:"view"}),".\nOnly logic that should go into a view is converting event payloads into value\nthey contain, and store them at some path in state. All the business logic\nbelongs in ",(0,o.jsx)(n.a,{href:"/docs/api/producer",children:"producer"}),"s."]}),"\n",(0,o.jsx)(n.p,{children:"Next steps are to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Add event listener for ",(0,o.jsx)(n.code,{children:"onKeyDown"})," in the input"]}),"\n",(0,o.jsx)(n.li,{children:"Convert the pressed key to the intent TodoForm want to express, and store it\nin the state"}),"\n",(0,o.jsx)(n.li,{children:"Create producers for committing and discarding the new todo"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"src/TodoForm.tsx"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'+ import { TodoItem, TodoStatuses, TodoModes } from "./types";\n\n+ enum NewTodoIntents {\n+  commit = "commit",\n+  discard = "discard"\n+}\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = update.newTodo.title,\n  newTodoTitle = observe.newTodo.title,\n+  updateNewTodoIntent = update.newTodo.intent\n}) => {\n+  const keyDownToIntent = (e) => {\n+    if (e.key === "Enter") {\n+      updateNewTodoIntent.set(NewTodoIntents.commit);\n+    }\n\n+    if (e.key === "Escape") {\n+      updateNewTodoIntent.set(NewTodoIntents.discard);\n+   }\n+  };\n\n  return (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n+      onKeyDown={keyDownToIntent}\n    />\n  );\n};\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"view"}),"s can contain as much logic as required to provide a clean API. A view's\nAPI is made up of two things:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Its input: props and global state"}),"\n",(0,o.jsx)(n.li,{children:"Its output: JSX and global state"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A good API do not reveal its implementation details. State shouldn't need to\nknow which key is getting pressed, but only what is the objective that a view\nwant to accomplish. To provide a clean API, an event listener can be created in\nthe view itself, which stores the intent of the TodoForm component in state in\n",(0,o.jsx)(n.code,{children:".newTodo.intent"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Using state as a communication mechanism between components and producers allows\nkeeping the views free of all business logic, which is kept in small producers\nwhich do one thing well. ",(0,o.jsx)(n.code,{children:"addNewTodo"})," is going to be one such producer. Make\nthese changes in ",(0,o.jsx)(n.code,{children:"src/TodoForm.tsx"})," to create a new producer:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const addNewTodo: producer = ({\n  newTodoIntent = observe.newTodo.intent,\n  getTitle = get.newTodo.title,\n  updateTodosById = update.todosById,\n  updateNewTodoTitle = update.newTodo.title,\n  updateNewTodoIntent = update.newTodo.intent,\n}) => {\n  if (newTodoIntent !== NewTodoIntents.commit) {\n    return;\n  }\n  updateNewTodoIntent.remove();\n  const title = getTitle.value().trim();\n  if (!title) return;\n  const id = String(new Date().getTime());\n  const newTodo: TodoItem = {\n    id,\n    title,\n    status: TodoStatuses.pending,\n    mode: TodoModes.viewing,\n  };\n\n  updateTodosById.merge({\n    [id]: newTodo,\n  });\n  updateNewTodoTitle.set(null);\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And add it to the list of ",(0,o.jsx)(n.code,{children:"TodoForm"}),"'s producers:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"+ TodoForm.producers([addNewTodo]);\n\nexport default TodoForm;\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"addNewTodo"})," producer is doing a couple of interesting things:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["It uses ",(0,o.jsx)(n.code,{children:"get.newTodo.title"})," instead of ",(0,o.jsx)(n.code,{children:"observe.newTodo.title"}),".\n",(0,o.jsx)(n.a,{href:"/docs/api/get",children:"get"})," is another macro, which provides a function to get live\nvalue from the state. It is very useful when our producer is doing something\nasynchronous and needs a value from state at a later time. Or as is the case\nnow, it allow accessing a value without ",(0,o.jsx)(n.code,{children:"observe"}),"ing it."]}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"producer"})," or ",(0,o.jsx)(n.code,{children:"view"})," gets triggered every time anything it ",(0,o.jsx)(n.code,{children:"observe"}),"\nchanges. ",(0,o.jsx)(n.code,{children:"addNewTodo"})," producer should not get called whenever ",(0,o.jsx)(n.code,{children:"newTodo.title"}),"\nchanges. It is only interested in changes in ",(0,o.jsx)(n.code,{children:"newTodoIntent"})]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Notice that a guard has been added in starting of the producer, which checks\nif state is valid for execution of this producer. This is a common pattern in\nEngine apps, since it recommends creating small, single-responsibility\nproducers. The guard checks if the intent of newTodo is to commit it, if it\nisn't, this producer should not do anything."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In the spirit of single-responsibility producers, another producer can be\ncreated to cancel adding a new todo if user presses Escape key."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const cancelAddingTodo: producer = ({\n  newTodoIntent = observe.newTodo.intent,\n  updateNewTodoTitle = update.newTodo.title,\n  updateNewTodoIntent = update.newTodo.intent,\n}) => {\n  if (newTodoIntent !== NewTodoIntents.discard) {\n    return;\n  }\n  updateNewTodoIntent.remove();\n  updateNewTodoTitle.set(null);\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice it has a guard similar to ",(0,o.jsx)(n.code,{children:"addNewTodo"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Adding it to ",(0,o.jsx)(n.code,{children:"TodoForm.producers"})," will bring it to life:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"- TodoForm.producers([addNewTodo]);\n+ TodoForm.producers([addNewTodo, cancelAddingTodo]);\n"})}),"\n",(0,o.jsxs)(n.p,{children:['Although new todos are getting added to the state, and "Pending count" in footer\nincreases on adding new todos, new todos are not shown in the todo list.\n',(0,o.jsx)(n.code,{children:"visibleTodoIds"})," in the state need to be kept in sync with changes in\n",(0,o.jsx)(n.code,{children:"todosById"}),". It is in charge of which todos are visible in the list. Question\nis, where do the producer for updating ",(0,o.jsx)(n.code,{children:"visibleTodoIds"})," belong? Should a\nproducer be added in ",(0,o.jsx)(n.code,{children:"TodoForm"}),", which adds the todos, or should it go in ",(0,o.jsx)(n.code,{children:"App"}),",\nwhich shows the list of todos?"]}),"\n",(0,o.jsxs)(n.p,{children:["Engine recommends that ",(0,o.jsx)(n.strong,{children:"views which consume the derived state should track\nit"}),". Add a producer in ",(0,o.jsx)(n.code,{children:"src/App.tsx"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const syncVisibleTodoIds: producer = ({\n  todosById = observe.todosById,\n  filter = observe.filter,\n  visibleTodoIds = update.visibleTodoIds,\n}) => {\n  const todoIdsToDisplay = Object.entries(todosById as TodosById)\n    .map(([key, value]) => {\n      switch (filter as TodoFilters) {\n        case TodoFilters.completed:\n          return value.status === TodoStatuses.done ? key : null;\n        case TodoFilters.pending:\n          return value.status === TodoStatuses.done ? null : key;\n        default:\n          return key;\n      }\n    })\n    .filter(Boolean);\n\n  visibleTodoIds.set(todoIdsToDisplay);\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This view is doing a bit more than just adding all the ",(0,o.jsx)(n.code,{children:"id"}),"s from ",(0,o.jsx)(n.code,{children:"todosById"}),".\nIt also accounts for existence of a ",(0,o.jsx)(n.code,{children:"filter"})," in state, which don't yet exist in\nstate. This is how ",(0,o.jsx)(n.strong,{children:"Engine help gradually evolving the state as application\nevolves"}),'. The filter will be set later, when user clicks on "All", "Active" and\n"Completed" buttons in the ',(0,o.jsx)(n.code,{children:"Footer"}),". But before that, add this producer to\n",(0,o.jsx)(n.code,{children:"App"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:"App.producers([syncVisibleTodoIds]);\n\nexport default App;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Before adding filters to state, let's create an enum to represent all the\npossible filters. In ",(0,o.jsx)(n.code,{children:"src/types.tsx"}),", add:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export enum TodoFilters {\n  all = "all",\n  completed = "completed",\n  pending = "pending",\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Making a very simply change to ",(0,o.jsx)(n.code,{children:"src/Footer.tsx"})," allows setting filters for\nvisible todos:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'- import { TodoItem, TodoStatuses } from "./types";\n+ import { TodoItem, TodoStatuses, TodoFilters } from "./types";\n\nconst Footer: view = ({\n  pendingCount = observe.pendingCount,\n+ filter = observe.filter,\n+ updateFilter = update.filter\n}) => (\n...\n      <ul className="filters">\n        <li>\n-         <a href="#/" className="selected">All</a>\n+         <a\n+           href="#/"\n+           className={filter === TodoFilters.all ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.all)}\n+         >\n+          All\n+         </a>\n        </li>\n        <li>\n-         <a href="#/active">Active</a>\n+         <a\n+           href="#/active"\n+           className={filter === TodoFilters.pending ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.pending)}\n+         >\n+           Active\n+         </a>\n        </li>\n        <li>\n-         <a href="#/completed">Completed</a>\n+         <a\n+           href="#/completed"\n+           className={filter === TodoFilters.completed ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.completed)}\n+         >\n+           Completed\n+         </a>\n        </li>\n      </ul>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["It's also possible to set an initial filter by setting it in the initial state.\nIn ",(0,o.jsx)(n.code,{children:"src/index.tsx"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-diff",children:'+ import { TodoFilters } from "./types";\n...\n  state: {\n    initial: {\n+     filter: TodoFilters.all,\n      todosById: {\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},9596:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(7402);const s={},d=o.createContext(s);function i(e){const n=o.useContext(d);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(d.Provider,{value:n},e.children)}}}]);